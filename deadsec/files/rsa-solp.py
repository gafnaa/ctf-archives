from Crypto.Util.number import long_to_bytes, inverse, isPrime
from math import isqrt

# Paste the given values here
n = 144984891276196734965453594256209014778963203195049670355310962211566848427398797530783430323749867255090629853380209396636638745366963860490911853783867871911069083374020499249275237733775351499948258100804272648855792462742236340233585752087494417128391287812954224836118997290379527266500377253541233541409
c = 120266872496180344790010286239079096230140095285248849852750641721628852518691698502144313546787272303406150072162647947041382841125823152331376276591975923978272581846998438986804573581487790011219372437422499974314459242841101560412534631063203123729213333507900106440128936135803619578547409588712629485231
hint = 867001369103284883200353678854849752814597815663813166812753132472401652940053476516493313874282097709359168310718974981469532463276979975446490353988
e = 65537

# We know the lower 500 bits of phi(n)
low_bits = hint
BITS_KNOWN = 500

# Try all possibilities for the top bits (e.g., for demo try 24 bits; increase this later)
for upper in range(1 << 24):
    phi_guess = (upper << BITS_KNOWN) | low_bits
    x = (n - phi_guess + 1) // 2
    s = x * x - n
    if s < 0:
        continue
    r = isqrt(s)
    if r * r != s:
        continue
    p = x + r
    q = x - r
    if p * q == n:
        print("[+] Found factors!")
        phi = (p - 1) * (q - 1)
        d = inverse(e, phi)
        m = pow(c, d, n)
        print("Flag:", long_to_bytes(m))
        break

